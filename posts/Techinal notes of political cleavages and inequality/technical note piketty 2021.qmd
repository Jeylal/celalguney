---
title: "Notes on the methodology of the WPID"
format: html
editor: visual
image: paretoline.png
---

```{r}
#| warning: false
#| message: false
#| echo: false


library(tidyverse)
library(haven)
setwd("F:/myblog/posts/Techinal notes of political cleavages and inequality")
```

## How far can we go with income brackets?

To build their database on [World political cleavages and inequality](https://wpid.world/), Piketty and his team had to use electoral survey data. One problem with these sources is that they collect income data through brackets, without reporting the overall income average of the sample or the average per bracket. This Thus poses the question of how far one can go in terms of statistical analysis with only income brackets as a source of information for income. I will here explore what can be done with such a variable as well as the [technical note](https://wid.world/document/building-the-world-political-cleavages-and-inequality-database-a-new-dataset-on-electoral-behaviors-in-50-democracies-1948-2020-world-inequality-lab-technical-note-2021-01/) that Piketty et al. (2021) provides to explain how they computed the vote share for income and education decile, which they claim is one of their main contributions on political cleavages and inequality.

### A first look on the WPID dataset

The wpid is based on an impressive [dataset](https://wpid.world/resources/en/zip/wpid-micro.zip) compiling electoral survey data of 500 elections since 1948. Since the technical note takes Canada's 2015 election as an example, I will use the latter here.

```{r}
#| warning: false
#| message: false
ca <- read_dta("ca.dta")
ca2015 <- ca %>% 
  filter(year == 2015)
rm(ca)
```

Note that there is already something weird here: in the dataset, the variable income has 20 brackets/categories here whereas it has 18 in the technical note. Since this is not so much of an issue, I will still work with this dataset and we just won't have the same results as in Piketty & al's example.

A first step in analyzing such a variable is to compute the frequency, relative frequency and the cumulative frequency and relative frequency:

```{r}
#| warning: false
#| message: false

income <- ca2015 %>% 
  count(inc) %>% 
  drop_na() %>% 
  mutate(
    cumfreq = cumsum(n),
    prop = n/sum(n),
    cumrelfreq = cumsum(prop))

head(income)
```

The decile can be added to the dataset with the function ntile():

```{r}
#| warning: false
#| message: false
#| cache: true

income <- income %>% 
  mutate(decile = ntile(inc, 10))

head(income)
```
According to the table, the first and second brackets belong to the first decile. This is correct for the first bracket, but only partially correct for the second. In fact, the relative frequency range of the second bracket is [0.0538; 0.137]; for this bracket to be only considered as belonging to the first decile, it should be distributed between [0; 0.1] like the first bracket ([0; 0.0538]). However, there is a part of the second bracket that belongs to the second decile. The wpid technical note explains how to deal with this: 

Let's make the assumption that the distribution within each bracket is uniform. If I want to know which proportion of the second bracket belongs to the first decile, I assume that $X \sim U[0.0538, 0.137]$ with X the individual of bracket 2. I want to compute $p(x) \in U[0;0.1]$, that is to say, the probability that the observation of bracket 2 are between 0 and 0.1: the first decile. The solution is thus:

$$
p(0 \leq x \leq 0.1) = p(x \leq 0.1) = \frac{0.1-0.0538}{0.137-0.0538} =  0.555
$$
In R:

```{r}
#| warning: false
#| message: false
punif(0.1, min = 0.0538, max = 0.137)
```
This means that 55% of the second bracket belongs to the first decile and 45% to the rest. A weighted average can then be computed to regroup the first decile: we take the proportion of bracket one multiplied by its weight (prop of it belonging to the first decile, which is one) and the proportion of bracket two multiplied by its weight (proportion of bracket two belonging to the first decile).

$$
\frac{0.0537*1 + 0.083*0.55}{1+0.55} = 0.06409677
$$
```{r}
weighted.mean(x = c(0.0537, 0.083), w = c(1, 0.55))*100
```

6.409 percent of total individuals belong to the first decile.



Let's do the same for the third bracket. Its distribution is also assumed uniform $U[0.13; 0.15]$, it is pretty straightforward that all of it belongs to the second decile since its upper limit does not cross 0.2. The upper limit of the fourth bracket does however cross 0.2: $U[0.157; 0.211]$

```{r}
punif(0.2, min = 0.157, max = 0.211)
```
79.6% of the fourth bracket belong to the second decile.

```{r}
weighted.mean(c(0.02, 0.0535), w = c(1, 0.079))
```
2.2 percent of total observations belong to the second decile.

All the steps directly with R:

```{r}
weighted.mean(x = c(income$prop[3], income$prop[4]), w = c(1, punif(0.2, min = income$cumrelfreq[3], max = income$cumrelfreq[4])))
```
There is some discrepancy due to the different rounding.


```{r}
weighted.mean(c(income$prop[5], income$prop[6]), w = c(1, punif(0.3, min = income$cumrelfreq[5], max = income$cumrelfreq[6])))
```

This would be tedious to go all the way up to the tenth decile. There is to my knowledge no function in R that will do this automatically and Piketty and his team use Stata so I can't take their code here. Indeed, a R function that would compute the correct relative frequencies for each decile from whatever income bracket would be really useful. But since I will perhaps go back to this in the future, let's see what can be done further with those income brackets. 

I will finish this post by trying to plot a "Pareto line", that is, to plot the relationship $log(N) = A - log(x)$ with N the number of individuals earning more than income level x. This can be done simply by plotting on the y axis the inverse of the relative cumulative distribution function and the log of income brackets on the x axis.

```{r}
#| warning: false
#| message: false

income %>% 
  ggplot()+
  aes(x = log(inc), y = log(rev(cumrelfreq)))+ #rev() to reverse the values to get the inverse of the relative cdf
  geom_smooth(method = "lm")+
  geom_point()+
  theme_bw()

coef(lm(data = income, log(rev(cumrelfreq)) ~ log(inc)))
```
We can see that the Pareto line does not fit the data very well, it would fit better only if the line was drawn for the top of the distribution


















